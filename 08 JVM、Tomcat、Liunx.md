# JVM

### JVM 内存划分

1. 方法区（线程共享）：常量、静态变量、JIT(即时编译器) 编译后的代码也都在方法区；
2. 堆内存（线程共享）：垃圾回收的主要场所；
3. 程序计数器： 当前线程执行的字节码的位置指示器；
4. 虚拟机栈（栈内存）：保存局部变量、基本数据类型变量以及堆内存中某个对象的引用变量；
5. 本地方法栈 ：为 JVM 提供使用 native 方法的服务。

### 堆和方法区

堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

### JMM基本概念

Java内存模型，JMM 本身是一种抽象的概念并不是真实存在，它描述的是一组规定或则规范，通过这组规范定义了程序中的访问方式。

三大特性：可见性、原子性、有序性

JMM 同步规定

- 线程解锁前，必须把共享变量的值刷新回主内存
- 线程加锁前，必须读取主内存的最新值到自己的工作内存
- 加锁解锁是同一把锁

由于 JVM 运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存，工作内存是每个线程的私有数据区域，而 Java  内存模型中规定所有变量的储存在主内存，主内存是共享内存区域，所有的线程都可以访问，但线程对变量的操作（读取赋值等）必须都工作内存进行。

首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。

内存模型图

![搜狗截图20190416211412](http://blog.cuzz.site/2019/04/16/Java并发编程/搜狗截图20190416211412.png)

### 堆内存、非堆内存的分配

堆内存分配：

1. JVM 初始分配的内存由-Xms 指定，默认是物理内存的 1/64；
2. JVM 最大分配的内存由-Xmx 指定，默认是物理内存的 1/4；
3. 默认空余堆内存小于 40% 时，JVM 就会增大堆直到-Xmx 的最大限制；空余堆内存大于 70% 时，JVM 会减少堆直到 -Xms 的最小限制；
4. 因此服务器一般设置-Xms、-Xmx 相等以避免在每次 GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。

非堆内存分配：

1. JVM 使用-XX:PermSize 设置非堆内存初始值，默认是物理内存的 1/64；
2. 由 XX:MaxPermSize 设置最大非堆内存的大小，默认是物理内存的 1/4；
3. -Xmn2G：设置年轻代大小为 2G；
4. -XX:SurvivorRatio，设置年轻代中 Eden 区与 Survivor 区的比值。

### 垃圾回收算法有哪些

1. 引用计数 ：原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为 0 的对象。此算法最缺点的是无法处理循环引用的问题。

2. 标记-清除 ：此算法执行分两阶段，第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时会产生内存碎片。

3. 复制算法 ：此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。

   此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现 “碎片” 问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。

4. 标记-整理 ：此算法结合了 “标记-清除” 和 “复制” 两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象和存活对象 “压缩” 到堆的其中一块，按顺序排放。此算法避免了 “标记-清除” 的碎片问题，同时也避免了 “复制” 算法的空间问题。

### root 搜索算法中，哪些可以作为 root

- 被启动类（bootstrap 加载器）加载的类和创建的对象；
- JavaStack 中的引用的对象 (栈内存中引用的对象)；
- 方法区中静态引用指向的对象；
- 方法区中常量引用指向的对象；
- Native 方法中 JNI 引用的对象。

### GC 什么时候开始？

GC 经常发生的区域是堆区，堆区还可以细分为新生代、老年代，新生代还分为一个 Eden 区和两个 Survivor 区。

1. 对象优先在 Eden 中分配，当 Eden 中没有足够空间时，虚拟机将发生一次 Minor GC，因为 Java 大多数对象都是朝生夕灭，所以 Minor GC 非常频繁，而且速度也很快；

2. Full GC，发生在老年代的 GC，当老年代没有足够的空间时即发生 Full GC，发生 Full GC 一般都会有一次 Minor GC。

   大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个 XX:PretenureSizeThreadhold 参数，令大于这个参数值的对象直接在老年代中分配，避免在 Eden 区和两个 Survivor 区发生大量的内存拷贝；

3. 发生 Minor GC 时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次 Full  GC，如果小于，则查看 HandlePromotionFailure 设置是否允许担保失败，如果允许，那只会进行一次 Minor  GC，如果不允许，则改为进行一次 Full GC。

### 内存泄漏和内存溢出

概念：

内存溢出指的是内存不够用了；内存泄漏是指对象可达，但是没用了。即本该被 GC 回收的对象并没有被回收；内存泄露是导致内存溢出的原因之一。

内存泄漏的原因分析：

1. 长生命周期的对象引用短生命周期的对象；
2. 没有将无用对象置为 null。

# Tomcat

# Liunx

1）grep、sed 以及 awk 命令

2）文件和目录：

- pwd 显示当前目录
- ls 显示当前目录下的文件和目录：
  - ls -F 可以区分文件和目录；
  - ls -a 可以把隐藏文件和普通文件一起显示出来；
  - ls -R 可以递归显示子目录中的文件和目录；
  - ls -l 显示长列表；
  - ls -l test 过滤器，查看某个特定文件信息，可以只查看 test 文件的信息。

3）处理文件方面的命令有：touch、cp、 In、mv、rm、      

4）处理目录方面的命令：mkdir

5）查看文件内容：file、cat、more、less、tail、head

6）监测程序命令：ps、top

​	eg. 找出进程名中包括 java 的所有进程：ps -ef | grep java

​	top 命令实时监测进程

​	top 命令输出的第一部分：显示系统的概括。

1. 第一行显示了当前时间、系统的运行时间、登录的用户数和系统的平均负载（平均负载有 3 个值：最近 1min 5min 15min）；
2. 第二行显示了进程的概要信息，有多少进程处于运行、休眠、停止或者僵化状态；
3. 第三行是 CPU 的概要信息；
4. 第四行是系统内存的状态。

7）ps 和 top 命令的区别：

1. ps 看到的是命令执行瞬间的进程信息 , 而 top 可以持续的监视；
2. ps 只是查看进程 , 而 top 还可以监视系统性能 , 如平均负载 、cpu 和内存的消耗；
3. top 还可以操作进程 , 如改变优先级 (命令 r) 和关闭进程 (命令 k)；
4. ps 主要是查看进程，关注点在于查看需要查看的进程；
5. top 主要看 cpu、内存使用情况，及占用资源最多的进程由高到低排序，关注点在于资源占用情况。

8） 压缩数据

1. tar -xvf 文件名；
2. tar -zxvf 文件名；
3. tar -cvzf 文件名。

9）结束进程：kill PID 或者 kill all







