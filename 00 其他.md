## Java8 新增知识点

1）HashMap 的底层实现有变化：HashMap 是数组 + 链表 + 红黑树（JDK1.8 增加了红黑树部分）实现。

2）JVM 内存管理方面，由元空间代替了永久代。

区别：

1. 元空间并不在虚拟机中，而是使用本地内存；
2. 默认情况下，元空间的大小仅受本地内存限制；
3. 也可以通过-XX：MetaspaceSize 指定元空间大小。

3）Lambda 表达式（也称为闭包），允许我们将函数当成参数传递给某个方法，或者把代码本身当做数据处理。

4）函数式接口：指的是只有一个函数的接口，java.lang.Runnable 和 java.util.concurrent.Callable 就是函数式接口的例子；java8 提供了一个特殊的注解  @Functionallnterface 来标明该接口是一个函数式接口。

| 常用函数式接口 | 使用方法                                          |
| -------------- | ------------------------------------------------- |
| Predicate      | 接收参数T对象，返回一个booean类型结果             |
| Consumer       | 接收参数T对象，没有返回值                         |
| Function       | 接收参数T对象，返回R对象                          |
| Supplier       | 不接受任何参数，直接通过get（）获取指定类型的对象 |
| Unaryoperator  | 按口参数T对象，执行业务处理后，返回更新后的T对象  |
| Binaryoperator | 接口接收两个对象，执行业务处理后，返一个T对象     |

5）引入重复注解：Java 8 中使用 @Repeatable 注解定义重复注解。

6）接口中可以实现方法静态方法和默认方法，区别是默认方法能被重写，静态方法不能。[代码示例](https://www.cnblogs.com/JimKing/p/9155096.html)

7） 注解的使用场景拓宽： 注解几乎可以使用在任何元素上，局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上。

8） 新的包 java.time 包

1. 包含了所有关于日期、时间、时区、持续时间和时钟操作的类；
2. 这些类都是不可变的、线程安全的。

## 系统架构相关问题

#### 如何提升网站性能、可用性以及并发量

1. 提高硬件能力、增加系统服务器。（当服务器增加到某个程度的时候系统所能提供的并发访问量几乎不变，所以不能根本解决问题）
2. 使用缓存（本地缓存：JDK自带的 Map、Guava Cache；分布式缓存：Redis、Memcache；本地缓存不适用于提高系统并发量。）
3. 消息队列 （解耦+削峰+异步）
4. 采用分布式开发 （不同的服务部署在不同的机器节点上，并且一个服务也可以部署在多台机器上，然后利用 Nginx 负载均衡访问，这样就解决了单点部署(All In)的缺点，大大提高了系统并发量）
5. 采用集群 （多台机器提供相同的服务）
6. 数据库分库（读写分离）、分表（水平分表、垂直分表）
7. CDN 加速 (将一些静态资源比如图片、视频等等缓存到离用户最近的网络节点)
8. 浏览器缓存
9. 使用合适的连接池（数据库连接池、线程池等等）
10. 适当使用多线程进行开发。

#### 设计高可用系统的常用手段

1. 降级： 服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也有时候可以随机服务。
2. 限流： 防止恶意请求流量、恶意攻击，或者防止流量超出系统峰值；
3. 缓存： 避免大量请求直接落到数据库，将数据库击垮；
4. 超时和重试机制： 避免请求堆积造成雪崩；
5. 回滚机制： 快速修复错误版本。

#### 对微服务的了解和认识

我们通常把 Spring Cloud 理解为一系列开源组件的集合，但是 Spring Cloud并不是等同于 Spring Cloud Netflix 的 Ribbon、Feign、Eureka（停止更新）、Hystrix 这一套组件，而是抽象了一套通用的开发模式。它的目的是通过抽象出这套通用的模式，让开发者更快更好地开发业务。但是这套开发模式运行时的实际载体，还是依赖于 RPC、网关、服务发现、配置管理、限流熔断、分布式链路跟踪等组件的具体实现。

Spring Cloud Alibaba 是官方认证的新一套 Spring Cloud 规范的实现。由阿里开源组件和阿里云产品组件两部分组成，其致力于提供微服务一站式解决方案，方便开发者通过 Spring Cloud 编程模型轻松开发微服务应用。

另外，Apache Dubbo Ecosystem 是围绕 Apache Dubbo 打造的微服务生态，是经过生产验证的微服务的最佳实践组合。在阿里巴巴的微服务解决方案中，Dubbo、Nacos 和 Sentinel，以及后续将开源的微服务组件，都是 Dubbo EcoSystem 的一部分。阿里后续也会将 Dubbo EcoSystem 集成到 Spring Cloud 的生态中。

#### 对 Dubbo 和 Spring Cloud 的认识

Dubbo 与 Spring Cloud 并不是竞争关系，Dubbo 作为成熟的 RPC 框架，其易用性、扩展性和健壮性已得到业界的认可。未来 Dubbo 将会作为 Spring Cloud Alibaba 的 RPC 组件，并与 Spring Cloud 原生的 Feign 以及 RestTemplate 进行无缝整合，实现“零”成本迁移。

#### 对性能测试的认识

性能测试指通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。性能测试是总称，通常细分为：

1. 基准测试： 在给系统施加较低压力时，查看系统的运行状况并记录相关数做为基础参考。
2. 负载测试： 是指对系统不断地增加压力或增加一定压力下的持续时间，直到系统的某项或多项性能指标达到安全临界值，例如某种资源已经达到饱和状态等 。此时继续加压，系统处理能力会下降。
3. 压力测试： 超过安全负载情况下，不断施加压力（增加并发请求），直到系统崩溃或无法处理任何请求，以此获得系统最大压力承受能力。
4. 稳定性测试： 被测试系统在特定硬件、软件、网络环境下，加载一定业务压力（模拟生产环境不同时间点、不均匀请求，呈波浪特性）运行一段较长时间，以此检测系统是否稳定。

后端程序员或者测试平常比较常用的测试工具是 JMeter。Apache JMeter 是一款基于Java的压力测试工具(100％纯Java应用程序)，旨在加载测试功能行为和测量性能。它最初被设计用于 Web 应用测试但后来扩展到其他测试领域。

#### 大表优化的常见手段

1. 限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句；
2. 读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；
3. 垂直分区：根据数据库里面数据表的相关性进行拆分。 垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 优点： 可以使得**行数据变小**，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以**简化表的结构，易于维护**。缺点： **主键会出现冗余**，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让**事务变得更加复杂**；
4. 水平分区：水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张表的数据拆成多张表来存放。如果分表的数据还是在同一台机器上，其实对于提升性能没有什么意义，所以水平拆分最好分库 。优点：水平拆分能够支持非常大的数据量存储，应用端改造也少；缺点：分片事务难以解决 ，跨界点Join性能较差，逻辑复杂。

数据库分片的两种常见方案：

- 客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。
- 中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。

#### 使用消息队列能带来什么好处

1) 通过异步处理提高系统性能

在不使用消息队列的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。

通过以上分析我们可以得出消息队列具有很好的**削峰**作用的功能——即通过异步处理，将短时间高并发产生的消息存储在消息队列中，从而削平高峰期的并发事务。 

2) 降低系统耦合度

分布式消息队列中消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者获取该消息后进行后续处理，并不需要知道该消息从何而来。对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。

#### 对 CAP 定理、BASE 理论的理解

**CAP 定理**

<img src="image\2e973ecb93c.jpeg" alt="CAP定理" style="zoom:50%;" />

在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer's theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：

- 一致性(Consistency) ： 客户端知道一系列的操作都会同时发生(生效)
- 可用性(Availability) ： 每个操作都必须以可预期的响应结束
- 分区容错性(Partition tolerance) ： 即使出现单个组件无法可用，操作依然可以完成

现在的分布式系统具有更多特性比如扩展性、可用性等等，在进行系统设计和开发时，我们不应该仅仅局限在CAP问题上。

为什么说三个特性无法全部保证呢？在保证分区容错性的前提下，必然要做多个副本节点，而这必然会带来一致性的问题，即保证多个节点的数据是相同的，但是，要让多个节点数据相同，就必须要花时间去复制数据，这还是能够正常通信的情况下，那么在数据复制的过程中为了保持一致性，就不能对外提供服务，所以这段时间就无法满足可用性的问题。
 实际工程通常会采取一些折中措施，比如并不保证强一致性，只保证最终一致性，什么意思呢？比如，有三个数据节点互为备份，某份数据在节点A更改后，需要将更改复制到节点B和C，假设复制过程中，有客户访问该数据，那么此时不保证是一致的，即访问A节点的用户得到的是最新数据，而访问B和C节点的用户得到是老数据，但是最终，数据会复制完成，所以最终A、B、C三个节点的数据是一致的。

- 为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；
- 为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。

**BASE 理论**

<img src="image\4806d9e15c6.jpeg" alt="BASE理论三要素" style="zoom:50%;" />

1. 基本可用： 指分布式系统在出现不可预知故障的时候，允许损失部分可用性；
2. 软状态： 指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时；
3. 最终一致性： 最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态，而不需要实时保证系统数据的强一致性。

BASE 是 Basically Available（基本可用） 、Soft-state（软状态） 和 Eventually Consistent（最终一致性） 三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，它大大降低了我们对系统的要求。

BASE理论的核心思想： 即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。

