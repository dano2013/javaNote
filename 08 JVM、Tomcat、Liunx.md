### RPC原理

RPC 让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。

<img src="image\7a35ce8888b64735b32eda312bed3d82.png" alt="RPC原理时序图" style="zoom:80%;" />

1. 服务消费方（client）本地调用方式调用服务；
2. client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；
3. client stub找到服务地址，并将消息发送到服务端；
4. server stub收到消息后进行解码；
5. server stub根据解码结果调用本地的服务；
6. 本地服务执行并将结果返回给server stub；
7. server stub将返回结果打包成消息并发送至消费方；
8. client stub接收到消息，并进行解码；
9. 服务消费方得到最终结果。

### 常见的 RPC 框架

- RMI： JDK自带的RPC，依赖于JVM，仅仅支持从一个JVM到另一个JVM的调用，不推荐使用。
- Dubbo：Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。
- gRPC：gRPC是可以在任何环境中运行的开源高性能RPC框架。它通过可插拔的支持来有效地连接数据中心和跨数据中心的服务，以实现负载均衡、跟踪、运行状况检查和身份验证。它也适用于分布式计算的最后一英里，以将设备、移动应用程序和浏览器连接到后端服务。
- Hessian： Hessian是一个轻量级的remoting on http工具，使用简单的方法提供了RMI的功能。相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，很适合于发送二进制数据。
- Thrift： Apache Thrift是Facebook开源的跨语言的RPC通信框架，目前已经捐献给Apache基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于thrift研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。

### 有 HTTP ，为什么用 RPC 进行服务调用

Rest vs RPC？ / RPC 传输一般基于什么协议？

RPC 只是一种概念、一种设计，是为了解决不同服务之间的调用问题，它一般包含有传输协议和序列化协议 。

实现 RPC 的传输协议可以建立在 TCP 之上，也可以建立在 HTTP 之上。大部分 RPC 框架都是使用的 TCP 连接（gRPC使用了HTTP2）。

因为 HTTP协议请求中会包含很多内容，传输效率比较低，一般RPC实现都不采用HTTP协议，而是采用自定义的TCP协议，可以<u>精简报文格式，客户端和服务端采用统一的序列化和反序列化方式保持数据统一</u>，效率更高，所以一般企业内部通信都是采用自定义TCP的RPC协议，传输效率高。

### 滑动窗口机制

由发送方和接收方在三次握手阶段，互相将自己的最大可接收的数据量告诉对方，也就是自己的数据接收缓冲池的大小。这样对方可以根据已发送的数据量来计算是否可以接着发送。

在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知。

### 拥塞避免机制

**拥塞：**对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随着负荷的增大而下降。

**拥塞控制：**防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。

**拥塞控制方法：**

- 慢开始 + 拥塞避免；
- 快重传 + 快恢复。

### 输入一个网址之后发生了什么

1. 由域名→IP 地址
   寻找 IP 地址的过程依次经过了浏览器缓存、系统缓存、hosts 文件、路由器缓存、 递归搜索根域名服务器。

2. 建立 TCP/IP 连接（三次握手具体过程）

3. 由浏览器发送一个 HTTP 请求

4. 经过路由器的转发，通过服务器的防火墙，该 HTTP 请求到达了服务器

5. 服务器处理该 HTTP 请求，返回一个 HTML 文件

6. 浏览器解析该 HTML 文件，并且显示在浏览器端

   

- HTTP 协议是一种基于 TCP/IP 的应用层协议，进行 HTTP 数据请求必须先建立 TCP/IP 连接
- 可以这样理解：HTTP 是轿车，提供了封装或者显示数据的具体形式；Socket 是发动机，提供了网络通信的能力。
- 两个计算机之间的交流无非是两个端口之间的数据通信 , 具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。

### 常见 HTTP 状态码

- 1xx（临时响应）
- 2xx（成功）
- 3xx（重定向）：表示要完成请求需要进一步操作
- 4xx（错误）：表示请求可能出错，妨碍了服务器的处理
- 5xx（服务器错误）：表示服务器在尝试处理请求时发生内部错误



常见状态码：

- 200（成功）
- 304（未修改）：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容
- 401（未授权）：请求要求身份验证
- 403（禁止）：服务器拒绝请求
- 404（未找到）：服务器找不到请求的网页

### Cookie及其作用

Cookies是某些网站为了辨别用户身份而储存在用户本地终端上的数据（通常经过加密）。**Cookie 存放在客户端，一般用来保存用户信息**。

下面是 Cookie 的一些应用案例：

1. 我们在 Cookie 中保存已经登录过的用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了。除此之外，Cookie 还能保存用户首选项，主题和其他设置信息。
2. 使用 Cookie 保存 session 或者 token ，向后端发送请求的时候带上 Cookie，这样后端就能取到session或者token了，这样就能记录用户当前的状态了。
3. Cookie 还可以用来记录和分析用户行为。举个简单的例子你在网上购物的时候，因为HTTP协议是没有状态的，如果服务器想要获取你在某个页面的停留状态或者看了哪些商品，一种常用的实现方式就是将这些信息存放在Cookie 。

### Cookie vs Session 

Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更高。敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。

### 如何使用Session进行身份验证

很多时候我们都是通过 SessionID 来识别特定的用户，SessionID 一般会选择存放在 Redis 中。举个例子：用户成功登陆系统，然后返回给客户端具有  SessionID 的 Cookie，当用户向后端发起请求的时候会把 SessionID  带上，这样后端就知道你的身份状态了。关于这种认证方式更详细的过程如下：

1. 用户向服务器发送用户名和密码用于登陆系统。
2. 服务器验证通过后，服务器为用户创建一个 Session，并将 Session信息存储起来。
3. 服务器向用户返回一个 SessionID，写入用户的 Cookie。
4. 当用户保持登录状态时，Cookie 将与每个后续请求一起被发送出去。
5. 服务器可以将存储在 Cookie 上的 Session ID 与存储在内存中或者数据库中的 Session 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态。

# JVM

### JVM 内存划分

1. 方法区（线程共享）：常量、静态变量、JIT(即时编译器) 编译后的代码也都在方法区；
2. 堆内存（线程共享）：垃圾回收的主要场所；
3. 程序计数器： 当前线程执行的字节码的位置指示器；
4. 虚拟机栈（栈内存）：保存局部变量、基本数据类型变量以及堆内存中某个对象的引用变量；
5. 本地方法栈 ：为 JVM 提供使用 native 方法的服务。

### 堆和方法区

堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

### JMM基本概念

Java内存模型，JMM 本身是一种抽象的概念并不是真实存在，它描述的是一组规定或者规范，通过这组规范定义了程序中的访问方式。

三大特性：可见性、原子性、有序性

JMM 同步规定

- 线程解锁前，必须把共享变量的值刷新回主内存
- 线程加锁前，必须读取主内存的最新值到自己的工作内存
- 加锁解锁是同一把锁

由于 JVM 运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存，工作内存是每个线程的私有数据区域，而 Java  内存模型中规定主内存是共享内存区域，所有的线程都可以访问，但线程对变量的操作（读取赋值等）必须都工作内存进行。

首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝；不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。

内存模型图

![搜狗截图20190416211412](http://blog.cuzz.site/2019/04/16/Java并发编程/搜狗截图20190416211412.png)

### 堆内存、非堆内存的分配

堆内存分配：

1. JVM 初始分配的内存由-Xms 指定，默认是物理内存的 1/64；
2. JVM 最大分配的内存由-Xmx 指定，默认是物理内存的 1/4；
3. 默认空余堆内存小于 40% 时，JVM 就会增大堆直到-Xmx 的最大限制；空余堆内存大于 70% 时，JVM 会减少堆直到 -Xms 的最小限制；
4. 因此服务器一般设置-Xms、-Xmx 相等以避免在每次 GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。

非堆内存分配：

1. -XX:PermSize：设置非堆内存初始值，默认是物理内存的 1/64；
2. -XX:MaxPermSize：设置非堆内存最大值，默认是物理内存的 1/4；
3. -Xmn2G：设置年轻代大小为 2G；
4. -XX:SurvivorRatio：设置年轻代中 Eden 区与 Survivor 区的比值。

### 垃圾回收算法有哪些

1. 引用计数：原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为 0 的对象。此算法的缺点是无法处理循环引用的问题。

2. 标记-清除：此算法执行分两阶段，第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时会产生内存碎片。

3. 复制算法：此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。

   此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现 “碎片” 问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。

4. 标记-整理 ：此算法结合了 “标记-清除” 和 “复制” 两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象和存活对象 “压缩” 到堆的其中一块，按顺序排放。此算法避免了 “标记-清除” 的碎片问题，同时也避免了 “复制” 算法的空间问题。

### root 搜索算法的根节点

- 被启动类（bootstrap 加载器）加载的类和创建的对象；
- JavaStack 中引用的对象 (栈内存中引用的对象)；
- 方法区中静态引用指向的对象；
- 方法区中常量引用指向的对象；
- Native 方法中 JNI 引用的对象。

### GC 什么时候开始

GC 经常发生的区域是堆，堆还可以细分为新生代、老年代，新生代还分为一个 Eden 区和两个 Survivor 区。

1. 对象优先在 Eden 中分配，当 Eden 中没有足够空间时，虚拟机将发生一次 Minor GC，因为 Java 大多数对象都是朝生夕灭，所以 Minor GC 非常频繁，而且速度也很快；

2. Full GC，发生在老年代的 GC，当老年代没有足够的空间时即发生 Full GC，发生 Full GC 一般都会有一次 Minor GC。

   大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个 XX:PretenureSizeThreadhold 参数，令大于这个参数值的对象直接在老年代中分配，避免在 Eden 区和两个 Survivor 区发生大量的内存拷贝；

3. 发生 Minor GC 时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次 Full  GC，如果小于，则查看 HandlePromotionFailure 设置是否允许担保失败，如果允许，那只会进行一次 Minor  GC，如果不允许，则改为进行一次 Full GC。

### 内存泄漏和内存溢出

内存溢出指的是内存不够用了；内存泄漏是指对象可达，但是没用了，即本该被 GC 回收的对象并没有被回收；内存泄露是导致内存溢出的原因之一。

内存泄漏的原因分析：

1. 长生命周期的对象引用短生命周期的对象；
2. 没有将无用对象置为 null。

# Tomcat

# Liunx

1）grep、sed 以及 awk 命令

2）文件和目录：

- pwd 显示当前目录
- ls 显示当前目录下的文件和目录：
  - ls -F 可以区分文件和目录；
  - ls -a 可以把隐藏文件和普通文件一起显示出来；
  - ls -R 可以递归显示子目录中的文件和目录；
  - ls -l 显示长列表；
  - ls -l test 过滤器，查看某个特定文件信息，可以只查看 test 文件的信息。

3）处理文件方面的命令有：touch、cp、 In、mv、rm、      

4）处理目录方面的命令：mkdir

5）查看文件内容：file、cat、more、less、tail、head

6）监测程序命令：ps、top

​	eg. 找出进程名中包括 java 的所有进程：ps -ef | grep java

​	top 命令实时监测进程

​	top 命令输出的第一部分：显示系统的概括。

1. 第一行显示了当前时间、系统的运行时间、登录的用户数和系统的平均负载（平均负载有 3 个值：最近 1min 5min 15min）；
2. 第二行显示了进程的概要信息，有多少进程处于运行、休眠、停止或者僵化状态；
3. 第三行是 CPU 的概要信息；
4. 第四行是系统内存的状态。

7）ps 和 top 命令的区别：

1. ps 看到的是命令执行瞬间的进程信息 , 而 top 可以持续的监视；
2. ps 只是查看进程 , 而 top 还可以监视系统性能 , 如平均负载 、cpu 和内存的消耗；
3. top 还可以操作进程 , 如改变优先级 (命令 r) 和关闭进程 (命令 k)；
4. ps 主要是查看进程，关注点在于查看需要查看的进程；
5. top 主要看 cpu、内存使用情况，及占用资源最多的进程由高到低排序，关注点在于资源占用情况。

8） 压缩数据

1. tar -xvf 文件名；
2. tar -zxvf 文件名；
3. tar -cvzf 文件名。

9）结束进程：kill PID 或者 kill all







