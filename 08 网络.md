| 名称      | 所属层                     | 定义                                      |
| --------- | -------------------------- | ----------------------------------------- |
| IP        | 网络层                     | 因特网协议                                |
| UDP       | 传输层                     | 提供无连接的数据报服务                    |
| TCP       | 传输层                     | 面向连接的传输控制协议                    |
| Socket    | 应用层和传输层之间的抽象层 | 将应用层的操作简化为几个接口              |
| WebSocket | 应用层                     | 实现全双工通信的传输协议                  |
| HTTP      | 应用层                     | 超文本传输协议                            |
| HTTPS     | 应用层                     | 安全通信的传输协议                        |
| RPC       |                            | 远程服务调用，基于HTTP或自定义TCP协议实现 |
| RMI       |                            | 远程方法调用，用于实现RPC的Java api       |

### 1.1 OSI七层协议

OSI是一个开放性的<u>通信系统互连参考模型</u>，是一种<u>协议规范</u>。

- 物理层 建立、维护、断开物理连接。（由底层网络定义协议）
- 数据链路层 建立逻辑连接、进行硬件地址寻址、差错校验等功能。（由底层网络定义协议）
- 网络层 进行逻辑地址寻址，实现不同网络之间的路径选择。常见协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP
- 传输层 定义传输数据的协议端口号，以及流控和差错校验。常见协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层
- 会话层 建立、管理、终止会话。（在五层模型里面已经合并到了应用层）对应主机进程，指本地主机与远程主机正在进行的会话
- 表示层 数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）常见格式有，JPEG、ASCll、DECOIC、加密格式等
- 应用层 网络服务与最终用户的一个接口。常见协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP

![](image\ccf0c0d71a64.gif)

### 1.2 TCP/IP

TCP/IP是为使用互联网而开发制定的协议族，是<u>利用 IP  进行通信时所必须用到的协议群的统称</u>。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于TCP/IP协议。

TCP/IP 模型在 OSI 模型的基础上进行了简化，变成了四层，对比如下：

![](image\f58f6ad856c6802b636d20d8f5ba2c3e.jpeg)

OSI 参考模型注重“通信协议必要的功能是什么”，而 TCP/IP 则更强调“在计算机上实现协议应该开发哪种程序”。

通过对网络协议的了解，<u>IP协议对应网络层，TCP协议对应于传输层，而HTTP协议对应于应用层</u>，从本质上来说，三者是不同层面的东西；如果打个比方的话，IP就像高速公路，TCP就如同卡车，http就如同货物，货物要装载在卡车并通过高速公路才能从一个地点送到另一个地点。

### 1.4 IP

IP协议（因特网协议）：根据数据包的目的IP地址来决定如何投递它。如果数据包不能直接发送给目标主机，那么IP协议就为它寻找合适的下一台路由器，并将数据包交付给该路由器转发，多次重复这一过程，数据包最终到达目标主机，或者由于发送失败而被丢弃。

### 1.5 UDP

UDP（<u>用户数据报协议</u>，User Data Protocol）是提供无连接的数据报服务，传输不可靠，可能丢包（类似于发短信）；面向非连接 、传输不可靠（可能丢包）、无序、传输少量数据（数据报模式）、速度快，对系统资源的要求少，程序结构较简单 ，UDP支持一对一，一对多，多对一和多对多的交互通信。

### 1.6 TCP 

TCP（<u>传输控制协议</u>，Transmission Control Protocol）是面向连接的传输控制协议，提供可靠的数据服务（类似于打电话）；面向连接、传输可靠（保证数据正确性）、有序（保证数据顺序）、传输大量数据（流模式）、速度慢、对系统资源的要求多，程序结构较复杂，每一条TCP连接只能是点到点的。

### TCP vs UDP 

1. 回答发送数据前是否存在建立连接的过程；
2. TCP 过确认机制，丢包可以重发，保证数据的正确性；UDP 不保证正确性，只是单纯的负责发送数据包；
3. UDP 是面向报文的。发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付给 IP 层，既不拆分，也不合并，而是保留这些报文的边界，因此应用程序需要选择合适的报文大小；
4. UDP 的头部，只有 8 个字节，相对于 TCP 头部的 20 个字节信息包的额外开销很小。

### 1.7 Socket

套接字，它是TCP/IP网络的API，是在<u>应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口</u>供应用层调用以实现进程在网络中通信。Socket是一组接口，在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

### 1.8 WebSocket

WebSocket协议是基于TCP的一种新的网络协议，<u>和HTTP协议一样属于应用层协议</u><u>，它实现了浏览器与服务器全双工(full-duplex)通信</u>，也就是允许服务器主动发送信息给客户端。（信息只能单向传送为单工；信息能双向传送但不能同时双向传送称为半双工；信息能够同时双向传送则称为全双工。）

HTTP 协议有一个缺陷：通信只能由客户端发起，做不到服务器主动向客户端推送信息。WebSocket最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。

### 1.9 HTTP

<u>超文本传输协议</u>（HyperText Transfer Protocal），<u>是基于请求与响应、无状态、应用层的一种网络传输协议</u>，一般格式都是json或者xml，基于TCP/IP实现，互联网上应用最为广泛的一种网络协议。

### 1.10 HTTPS

HTTPS是一种<u>通过计算机网络进行安全通信的传输协议</u>，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。

HTTPS的优点
使用HTTPS协议<u>可认证用户和服务器</u>，确保数据发送到正确的客户机和服务器；
HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、改变，<u>确保数据的完整性</u>。
HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅<u>增加了中间人攻击的成本</u>。
谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。

HTTPS的缺点
HTTPS协议<u>握手阶段比较费时</u>，会使页面的加载时间延长近50%，增加10%到20%的耗电；
HTTPS<u>连接缓存不如HTTP高效</u>，流量成本高，甚至已有的安全措施也会因此而受到影响；
SSL证书需要钱，<u>功能越强大的证书费用越高</u>，个人网站、小网站没有必要一般不会用。
SSL证书通常需要绑定IP，<u>不能在同一IP上绑定多个域名</u>，IPv4资源不可能支撑这个消耗。
HTTPS协议的<u>加密范围也比较有限</u>，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。

比较好的方式是采用分而治之，类似12306网站的主页使用HTTP协议，有关于用户信息等方面使用HTTPS。

### 1.10 HTTP vs TCP

HTTP 属于应用层协议，它是基于TCP/IP通信协议来传递数据的。HTTP协议工作于客户端-服务端架构之上。浏览器作为HTTP客户端通过 URL 向HTTP服务端即WEB服务器发送请求，Web服务器根据接收到的请求向客户端发送响应信息。

TCP 属于传输层协议，主要解决数据如何在网络中传输。

>应用层的任务是通过应用进程间的交互来完成特定网络应用。
>
>传输层的任务是负责向两台主机进程之间的通信提供通用的数据传输服务。

首先要否认一点 HTTP 协议相较于自定义 TCP 报文协议，增加的开销在于连接的建立与断开。HTTP  协议是支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。并且HTTP 也可以使用 Protobuf  这种二进制编码协议对内容进行编码，因此二者最大的区别还是在传输协议上。

HTTP协议的 TCP 报文包含太多在传输过程中可能无用的信息，使用自定义 TCP 协议进行传输就会避免这个问题，极大地减轻了传输数据的开销。

### 2.1 RPC

<u>远程服务/过程调用</u>（Remote Procedure Call），<u>它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议</u>。加上Protocol后可以称为远程过程调用协议，可以用不同的语言实现。

###  2.2 RMI

<u>远程方法调用</u>（Remote Method Invocation），<u>是一种用于实现RPC的java API</u>，仅仅应用在java程序上，依赖于JVM，因为他仅仅支持从一个JVM到另一个JVM的调用。 

### 3.1 Rest

<u>Rest指的是一组架构约束条件和原则</u>，全称是Representational State Transfer，中文意思是表现层状态转化。REST规范把所有内容都视为资源，网络上一切皆资源。

资源（Resources）
所谓"资源"，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。REST的名称"表现层状态转化"中，省略了主语。"表现层"其实指的是"资源"（Resources）的"表现层"。

表现层（Representation）
"资源"是一种信息实体，它可以有多种外在表现形式。我们把"资源"具体呈现出来的形式，叫做它的"表现层"（Representation）。比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的".html"后缀名是不必要的，因为这个后缀名表示格式，属于"表现层"范畴，而URI应该只代表"资源"的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对"表现层"的描述。

状态转化（State Transfer）
访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生"状态转化"（State Transfer）。

 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。

我们现在所说的Rest是基于HTTP协议之上来讲的，但Rest架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与Rest相关的实例。

### 3.2 Restful

<u>如果一个架构符合Rest的约束条件和原则，我们就称它为Restful架构</u>。

Restful架构的主要原则

- 在Rest中的一切都被认为是一种资源。
- 每个资源由URI标识。
- 使用统一的接口。处理资源使用POST，GET，PUT，DELETE操作类似创建，读取，更新和删除（CRUD）操作。
- 无状态：每个请求是一个独立的请求。从客户端到服务器的每个请求都必须包含所有必要的信息，以便于理解。
- 同一个资源具有多种表现形式，例如XML，JSON

### 3.3 Rest vs RPC

都是网络交互的协议规范。通常用于多个微服务之间的通信协议。

1、HTTP相对更规范，更标准，更通用，无论哪种语言都支持http协议。如果你是对外开放API，例如开放平台，外部的编程语言多种多样，你无法拒绝对每种语言的支持，现在开源中间件，基本最先支持的几个协议都包含RESTful。

2、 RPC 框架作为架构微服务化的基础组件 ，它能大大降低架构微服务化的成本，提高调用方与服务提供方的研发效率，屏蔽跨进程调用函数（服务）的各类复杂细节。让调用方感觉就像调用本地函数一样调用远端函数、让服务提供方感觉就像实现一个本地函数一样来实现服务。

3、REST调用及测试都很方便，RPC就显得有点繁琐，但是RPC的效率是毋庸置疑的，所以建议在多系统之间的内部调用采用RPC。对外提供的服务，Rest更加合适。

|          | REST         | RPC         |
| -------- | ------------ | ----------- |
| 通信协议 | 目前基于HTTP | 一般使用TCP |
| 性能     | 低           | 高          |
| 灵活度   | 高           | 低          |

### 4 SSL/TLS

SSL 是“Secure Sockets Layer”的缩写，中文叫做“安全套接层”。

<u>SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。</u>

原先互联网上使用的 HTTP 协议是明文的，存在很多缺点，比如传输内容会被偷窥（嗅探）和篡改。发明 SSL 协议，就是为了解决这些问题。到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。所以这两者其实就是同一种协议，只不过是在不同阶段的不同称呼。

### 5 GET vs POST

GET参数通过URL传递，POST放在Request body中。（实际上，GET和POST都是HTTP协议中的两种发送请求的方法，本质上就是TCP链接，并无差别。要给GET加上request body，给POST带上url参数，技术上是完全行的通的。但是GET请求的request body有些服务器会直接忽略 ）因此GET比POST更不安全，不能用来传递敏感信息。

GET请求在URL中传送的参数是有长度限制的，而POST没有。（实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制，这个限制是特定的浏览器及服务器对它的限制。）

GET产生一个TCP数据包；POST产生两个TCP数据包。（对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200。但并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次，并且两次包的TCP在验证数据包完整性上有非常大的优点。）

GET请求只能进行url编码，而POST支持多种编码方式。

GET产生的URL地址可以被Bookmark，而POST不可以。

GET请求会被浏览器主动cache，而POST不会，除非手动设置。

GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

GET在浏览器回退时是无害的，而POST会再次提交请求。

### 6 URI vs URL vs URN

URI：Universal Resource Identifier(统一资源标志符)，用来标识抽象或物理资源的一个紧凑字符串。所以这就只是一个标志，并不能标识其具体位置或者唯一性。

URL：Universal Resource Locator(统一资源定位符)，一种定位资源的主要访问机制的字符串，一个标准的URL必须包括：protocol、host、port、path、parameter、anchor；

URN ：Universal Resource Name （统一资源名称），通过特定命名空间中的唯一名称或ID来标识资源，但是不给出实体的位置，通过引用一个或多个URL来实现标识指针功能。现实中可见的使用：P2P下载中使用的磁力链接。

<img src="image\1612448-20190303144907774-893688563.png" style="zoom:67%;" />

URL主要用于链接网页、网页组件或网页上的程序，借助访问方法（http，ftp，telnet等协议）来检索位置资源。相反，URI（统一资源标识符）用于定义项目的标识，表示将一个资源与其他资源区分开，而不管使用的方法（URL或URN），URL指定要使用的协议类型，而URI不涉及协议规范。



### RPC原理/实现过程

<img src="image\7a35ce8888b64735b32eda312bed3d82.png" alt="RPC原理时序图" style="zoom:80%;" />

1. 服务消费方（client）本地调用方式调用服务；
2. client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；
3. client stub找到服务地址，并将消息发送到服务端；
4. server stub收到消息后进行解码；
5. server stub根据解码结果调用本地的服务；
6. 本地服务执行并将结果返回给server stub；
7. server stub将返回结果打包成消息并发送至消费方；
8. client stub接收到消息，并进行解码；
9. 服务消费方得到最终结果。

### RPC 解决了什么问题

让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。

### 常见的 RPC 框架总结

- RMI： JDK自带的RPC，依赖于JVM，仅仅支持从一个JVM到另一个JVM的调用，不推荐使用。
- Dubbo：Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。
- gRPC：gRPC是可以在任何环境中运行的开源高性能RPC框架。它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载均衡、跟踪、运行状况检查和身份验证。它也适用于分布式计算的最后一英里，以将设备、移动应用程序和浏览器连接到后端服务。
- Hessian： Hessian是一个轻量级的remoting on http工具，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，很适合于发送二进制数据。
- Thrift： Apache Thrift是Facebook开源的跨语言的RPC通信框架，目前已经捐献给Apache基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于thrift研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。

### 有 HTTP ，为什么用 RPC 进行服务调用

RPC传输一般基于什么协议？

RPC 只是一种概念、一种设计，是为了解决不同服务之间的调用问题，它一般包含有传输协议和序列化协议 。

实现 RPC 的传输协议可以建立在 TCP 之上，也可以建立在 HTTP 之上。大部分 RPC 框架都是使用的 TCP 连接（gRPC使用了HTTP2）。

因为 HTTP协议请求中会包含很多内容，传输效率比较低，一般RPC实现都不采用HTTP协议；而是采用自定义的TCP协议，可以<u>精简报文格式，客户端和服务端采用统一的序列化和反序列化方式保持数据统一</u>，效率更高，所以一般企业内部通信都是采用自定义TCP的RPC协议，传输效率高。

### 三次握手、四次挥手

**![img](http://mmbiz.qpic.cn/mmbiz_jpg/0vU1ia3htaaOibXu9vz5RhIObf10CiaFxEVKlPMH6fdq80BhiaEqwEMNsSQ4icMXVMbd9fhA6gMId7CGAviacmJvibzlw/?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)**

总共有四种状态：主动建立连接、主动断开连接、被动建立连接和被动断开连接

两两组合共有 4 种组合：

1. 主动建立连接、主动断开连接会经历的状态：
   SYNC_SENT——ESTABLISHED—-FIN_WAIT_1—-FIN_WAIT_2—-TIME_WAIT
2. 主动建立连接、被动断开连接会经历的状态：
   SYNC_SENT——ESTABLISHED—-CLOSE_WAIT—-LAST_ACK
3. 被动建立连接、主动断开连接会经历的状态：
   LISTEN—-SYN_RCVD—-ESTABLISHED—-FIN_WAIT_1—-FIN_WAIT_2—-TIME_WAIT
4. 被动建立连接、被动断开连接会经历的状态：
   LISTEN—-SYN_RCVD—-ESTABLISHED—-CLOSE_WAIT—-LAST_ACK

### 滑动窗口机制

由发送方和接收方在三次握手阶段，互相将自己的最大可接收的数据量告诉对方，也就是自己的数据接收缓冲池的大小。这样对方可以根据已发送的数据量来计算是否可以接着发送。

在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知。

### 拥塞避免机制

**拥塞：**对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随着负荷的增大而下降。

**拥塞控制：**防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。

**拥塞控制方法：**

- 慢开始 + 拥塞避免；
- 快重传 + 快恢复。

![img](http://mmbiz.qpic.cn/mmbiz_png/0vU1ia3htaaOibXu9vz5RhIObf10CiaFxEV2iaXiamT52GkHNFtglg2bCU4kicFxp2RxrTicmrxibt2rdjia0ib4Y8hBx0hg/?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![img](http://mmbiz.qpic.cn/mmbiz_png/0vU1ia3htaaOibXu9vz5RhIObf10CiaFxEV2TpU4V9UDhmo5vNIGQGAcRWVGJof2icMMPm2XGZRL4A8t8aPliczibGjQ/?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 输入一个网址之后都发生了什么

1. 由域名→IP 地址
   寻找 IP 地址的过程依次经过了浏览器缓存、系统缓存、hosts 文件、路由器缓存、 递归搜索根域名服务器。

2. 建立 TCP/IP 连接（三次握手具体过程）

3. 由浏览器发送一个 HTTP 请求

4. 经过路由器的转发，通过服务器的防火墙，该 HTTP 请求到达了服务器

5. 服务器处理该 HTTP 请求，返回一个 HTML 文件

6. 浏览器解析该 HTML 文件，并且显示在浏览器端

   

- HTTP 协议是一种基于 TCP/IP 的应用层协议，进行 HTTP 数据请求必须先建立 TCP/IP 连接
- 可以这样理解：HTTP 是轿车，提供了封装或者显示数据的具体形式；Socket 是发动机，提供了网络通信的能力。
- 两个计算机之间的交流无非是两个端口之间的数据通信 , 具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。

### 常见 HTTP 状态码

- 1xx（临时响应）
- 2xx（成功）
- 3xx（重定向）：表示要完成请求需要进一步操作
- 4xx（错误）：表示请求可能出错，妨碍了服务器的处理
- 5xx（服务器错误）：表示服务器在尝试处理请求时发生内部错误



常见状态码：

- 200（成功）
- 304（未修改）：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容
- 401（未授权）：请求要求身份验证
- 403（禁止）：服务器拒绝请求
- 404（未找到）：服务器找不到请求的网页

### 什么是Cookie？Cookie的作用是什么

维基百科是这样定义 Cookie 的：Cookies是某些网站为了辨别用户身份而储存在用户本地终端上的数据（通常经过加密）。简单来说： **Cookie 存放在客户端，一般用来保存用户信息**。

下面是 Cookie 的一些应用案例：

1. 我们在 Cookie 中保存已经登录过的用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了。除此之外，Cookie 还能保存用户首选项，主题和其他设置信息。
2. 使用Cookie 保存 session 或者 token ，向后端发送请求的时候带上 Cookie，这样后端就能取到session或者token了。这样就能记录用户当前的状态了，因为 HTTP 协议是无状态的。
3. Cookie 还可以用来记录和分析用户行为。举个简单的例子你在网上购物的时候，因为HTTP协议是没有状态的，如果服务器想要获取你在某个页面的停留状态或者看了哪些商品，一种常用的实现方式就是将这些信息存放在Cookie 。

### Cookie 和 Session 有什么区别

Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更高。敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。

### 如何使用Session进行身份验证

很多时候我们都是通过 SessionID 来识别特定的用户，SessionID 一般会选择存放在 Redis 中。举个例子：用户成功登陆系统，然后返回给客户端具有  SessionID 的 Cookie，当用户向后端发起请求的时候会把 SessionID  带上，这样后端就知道你的身份状态了。关于这种认证方式更详细的过程如下：

1. 用户向服务器发送用户名和密码用于登陆系统。
2. 服务器验证通过后，服务器为用户创建一个 Session，并将 Session信息存储 起来。
3. 服务器向用户返回一个 SessionID，写入用户的 Cookie。
4. 当用户保持登录状态时，Cookie 将与每个后续请求一起被发送出去。
5. 服务器可以将存储在 Cookie 上的 Session ID 与存储在内存中或者数据库中的 Session 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态。