### 数据库分类

关系型数据库：最典型的数据结构是表，是二维表和其之间的联系所组成的数据组织

- 优点：易于维护，都是使用表结构，格式一致;使用方便，SQL语言通用，可用于复杂查询。
- 缺点：读写性能比较差，尤其是海量数据的高效率读写；固定的表结构，灵活性稍微欠缺。



非关系型数据库：一种数据结构化存储方法的集合，可以是文档或者键值对

- 优点：格式灵活，存储数据的格式可以是键值对形式、文档形式、图片形式等；速度快，nosql可以使用硬盘或者随机存储器作为载体，关系型数据库只能使用硬盘；高扩展性；成本低，nosql部署简单，基本上都是开源软件。

- 缺点：无事务处理；数据结构相对复杂，复杂查询方面欠缺。

### 数据库范式

**1NF(第一范式)**

要求数据库表的每一列都是不可分割的原子数据项。（比如“家庭信息”、“学校信息”就不满足原子性的要求，应该分成“家庭人口”、“户籍”、“学历”、“所在年级”）

**2NF(第二范式)**

第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。（比如订单表中主键是“订单号”+“产品号”，这时“订单金额”、“订单时间”和主键的某一部分“产品号”没有关系，应该将这两个字段分出去另建一张表）

**3NF(第三范式)**

第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。（比如班级表的主键是“学生学号”，但“班主任姓名”、“班主任年龄”直接依赖的是“教工号”，而不是“学生学号”，因此班级表中应该只有“教工号”，不应该再有班主任的其他信息）

### 数据库设计步骤

1. **需求分析** : 分析用户的需求，包括数据、功能和性能需求。
2. **概念结构设计** : 主要采用E-R模型进行设计，包括画E-R图。
3. **逻辑结构设计** : 通过将E-R图转换成表，实现从E-R模型到关系模型的转换。
4. **物理结构设计** : 主要是为所设计的数据库选择合适的存储结构和存取路径。
5. **数据库实施** : 包括编程、测试和试运行
6. **数据库的运行和维护** : 系统的运行与数据库的日常维护。

### ER图

E-R图也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，是表示概念关系模型的一种方式。

### 主键 vs 外键

- **主键(主码)** ：主键用于唯一标识一条数据，不能有重复，不允许为空。一张表只能有一个主键。
- **外键(外码)** ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。

### 什么是存储过程

我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串SQL语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯SQL语句执行要快，因为存储过程是预编译过的。

存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。

### DML 语句 vs DDL 语句

- DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作。
- DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。

DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。

### drop、delete与truncate

- drop(丢弃数据): drop table 表名 ，直接将表都删除掉，在删除表的时候使用。
- truncate (清空数据) : truncate table 表名 ，只删除表中的数据，再插入数据的时候自增长id又从1开始，在清空表中数据的时候使用。
- delete（删除数据） : delete from 表名 where 列名=值，删除某一列的数据，如果不加 where 子句和truncate 作用类似。

一般来说：drop>truncate>delete

drop 和truncate属于DDL，操作立即生效，不能回滚，操作不触发 trigger。而 delete 语句是DML，事务提交之后才生效。

### 事务的特性

事务是逻辑上的一组操作，要么都执行，要么都不执行

事务的特性（ACID）

- 原子性（Atomicity）：事务中所涉及的程序对数据库的修改操作要么全部成功，要么全部失败。
- 一致性（Consistency）：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。
- 隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据是独立的，相互不影响。
- 持久性（Durubility）：一旦事务成功提交，它对数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 事务的并发问题

- 脏读：读取未提交数据；A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。
- 不可重复读：前后多次读取，数据内容不一致；在一个事务中前后两次读取的结果不一致，导致了不可重复读。
- 幻读：前后多次读取，数据总量不一致；在一个事务中前后两次统计数据总量不一致，称为幻读。

不可重复读的重点是修改，幻读的重点在于新增或者删除。


### 事务隔离级别

1. read uncommitted 读取未提交：允许读取尚未提交的数据变更。
2. read committed 读取已提交：事务成功提交后才可以被查询到。

3. repeatable 可重复读：对同一字段的多次读取结果是一致的，但可能将未提交的记录查询出来，而出现幻读。

4. Serializable 可串行化：所有的事务依次逐个执行，在每个读数据行上添加共享锁，这样事务之间就完全不可能产生干扰，会导致大量超时现象和锁竞争。

| **隔离级别** | **脏读** | **不可重复读** | **幻读** |
| ------------ | -------- | -------------- | -------- |
| 读取未提交   | √        | √              | √        |
| 读取已提交   | ×        | √              | √        |
| 可重复读     | ×        | ×              | √        |
| 可串行化     | ×        | ×              | ×        |

## 索引

索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。

### 为什么索引能提高查询速度

MySQL的基本存储结构是页(记录都存在页里边)：

- **各个数据页可以组成一个双向链表**
- **每个数据页中的记录又可以组成一个单向链表**

  - 每个数据页都会为存储在它里边的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录

  - 以其他列(非主键)作为搜索条件时只能从最小记录开始依次遍历单链表中的每条记录。


当使用没有索引的非主键进行查询时，默认会这样做（时间复杂度为O（n））：

1. **定位到记录所在的页：需要遍历双向链表，找到所在的页**
2. **从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表**

索引将无序的数据变成有序(相对)，通过 “目录” 可以很快地定位到对应的页上（二分查找，时间复杂度近似为O(logn)）。

底层结构是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。

### 最左前缀原则

MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：

```sql
select * from user where name=xx and city=xx ; ／／可以命中索引
select * from user where name=xx ; // 可以命中索引
select * from user where city=xx ; // 无法命中索引            
```

这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 city= xx and name ＝xx，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。

由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则。

### 避免冗余索引

冗余索引指的是索引的功能相同，能够命中后者的查询肯定是能够命中前者的；如（name,city ）和（name ）这两个索引就是冗余索引， 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

MySQLS.7 版本后，可以通过查询 sys 库的 schema_redundant_indexes 表来查看冗余索引。

### 索引的类别

为表字段添加索引

```sql
--添加PRIMARY KEY（主键索引）
ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 
--添加UNIQUE(唯一索引)
ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 
--添加INDEX(普通索引)
ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
--添加FULLTEXT(全文索引)
ALTER TABLE `table_name` ADD FULLTEXT ( `column`) 
--添加多列索引
ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
```

## 乐观锁与悲观锁

### 悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到拿到锁，一般多写的场景下用悲观锁就比较合适。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

### 乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。**乐观锁适用于多读少写的应用场景，这样可以提高吞吐量**，像数据库提供的类似于**write_condition机制**，其实都是提供的乐观锁。

### 乐观锁的实现方式

乐观锁一般会使用版本号机制或CAS算法实现

**版本号机制**

一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值与当前数据库中的version值相等时才更新。

**CAS算法**

即compare and swap（比较与交换），是一种有名的无锁算法。即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数

- 需要读写的内存值 V
- 进行比较的值 A
- 拟写入的新值 B

当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，一般情况下是一个自旋操作，即不断的重试。

### **CAS**算法的缺点

**ABA** 问题

如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？

**循环时间长开销大**

自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 

**只能保证一个共享变量的原子操作**

CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作，所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。

### 表级锁 vs 行级锁

- 表级锁：对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
- 行级锁：只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

### MyISAM vs InnoDB

MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的 ISAM （Indexed Sequential Access Method：有索引的顺序访问方法）所改良，虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（另一种数据库引擎）。

大多数时候我们使用的都是InnoDB存储引擎，但是在某些情况下使用 MyISAM 也是合适的比如读密集的情况下。

**两者的对比：**

1. 是否支持行级锁 : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁，默认为行级锁。
2. 是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性，其执行速度比InnoDB更快，但是不提供事务支持。InnoDB 提供事务支持，外部键等高级数据库功能。 
3. 是否支持外键： MyISAM不支持，InnoDB支持。
4. 是否支持MVCC ：仅 InnoDB 支持。应对高并发事务MVCC比单纯的加锁更高效；MVCC只在读取已提交和可重复读两个隔离级别下工作；MVCC可以使用乐观锁和悲观锁来实现。

### 大表优化

当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：

**限定数据的范围**

禁止不带任何限制数据范围条件的查询语句；

**读写分离**

经典的数据库拆分方案，主库负责写，从库负责读；

**垂直分区**

根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。

简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 

- **垂直拆分的优点：** 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
- **垂直拆分的缺点：** 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂。

**水平分区**

水平拆分是指数据表行的拆分，保持数据表结构不变，通过某种策略存储数据分片；这样每一片数据分散到不同的表或者库中，达到了分布式的目的； 水平拆分可以支撑非常大的数据量。

分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 **水平拆分最好分库** 。

水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决** ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。

**数据库分片的两种常见方案：**

- **客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。** 当当网的 **Sharding-JDBC** 、阿里的TDDL是两种比较常用的实现。
- **中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在谈的 **Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。

### MySQL vs Oracle

**数据类型**：

- MySQL的非空字段也有空的内容，Oracle里定义了非空字段就不容许有空的内容；
- MySQL直接在sql语句中写limit就可以实现分页，Oracle需要用到伪列rownum和嵌套查询；
- MySql里可以使用双引号来包起字符串，Oracle里要使用单引号包起字符串；
- MySQL日期字段分DATE（年月日）和TIME（时分秒）两种，Oracle日期字段只有DATE，包含年月日时分秒信息；
- MySql一般使用自动增长类型，在创建表的时候只要指定表的主键为auto increment，插入记录时就不需要再为主键添加记录了，主键会自动增长。Oracle中没有自动增长，主键一般使用序列，插入记录时将序列号的下一个值付给该字段即可；

**权限管理**：？？？

- 

**事务隔离**：

- mysql默认的事务处理级别是REPEATABLE-READ（可重复读）
- oracle支持READ COMMITTED（读已提交） 和 SERIALIZABLE（可串行化）这两种事务隔离级别，默认是读已提交。

**其他**：

- MySQL是轻量级数据库，开源免费，Oracle付费，且安装所需空间更大；
- MySQL默认是自动提交，Oracle默认不自动提交，需要用户手动提交；
- MySQL以表级锁为主，对资源锁定的粒度很大，Oracle使用行级锁；（**存疑**）
- MySQL管理工具较少，Oracle有多种成熟的命令行，图形界面，web管理工具，管理极其方便高效；
- MySQL在数据库更新或者重启，就会丢失数据，Oracle把提交的sql操作栈写入了在线联机日志文件中，保存到了磁盘上，可以随时恢复；
- MySQL的默认端口号是3306







