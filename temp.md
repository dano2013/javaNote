### （三）高并发编程-JUC 包

### 多线程和单线程的区别和联系

答：

1. 在单核 CPU 中，将 CPU 分为很小的时间片，在每一时刻只能有一个线程在执行，是一种微观上轮流占用 CPU 的机制。
2. 多线程会存在线程上下文切换，会导致程序执行速度变慢，即采用一个拥有两个线程的进程执行所需要的时间比一个线程的进程执行两次所需要的时间要多一些。

结论：即采用多线程不会提高程序的执行速度，反而会降低速度，但是对于用户来说，可以减少用户的响应时间。

**2）如何指定多个线程的执行顺序？**

解析：面试官会给你举个例子，如何让 10 个线程按照顺序打印 0123456789？（写代码实现）

答：

1. 设定一个 orderNum，每个线程执行结束之后，更新 orderNum，指明下一个要执行的线程。并且唤醒所有的等待线程。
2. 在每一个线程的开始，要 while 判断 orderNum 是否等于自己的要求值！！不是，则 wait，是则执行本线程。

**3）线程和进程的区别：（必考）**

答：

1. 进程是一个 “执行中的程序”，是系统进行资源分配和调度的一个独立单位；

2. 线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源（所以通信和同步等操作线程比进程更加容易）；

3. 线程上下文的切换比进程上下文切换要快很多。

4. - （1）进程切换时，涉及到当前进程的 CPU 环境的保存和新被调度运行进程的 CPU 环境的设置。
   - （2）线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。

**4）多线程产生死锁的 4 个必要条件？**

答：

1. 互斥条件：一个资源每次只能被一个线程使用；
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；
3. 不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺；
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。

**面试官：如何避免死锁？（经常接着问这个问题哦~）**

答：指定获取锁的顺序，举例如下：

1. 比如某个线程只有获得 A 锁和 B 锁才能对某资源进行操作，在多线程条件下，如何避免死锁？
2. 获得锁的顺序是一定的，比如规定，只有获得 A 锁的线程才有资格获取 B 锁，按顺序获取锁就可以避免死锁！！！

**5）sleep( ) 和 wait( n)、wait( ) 的区别：**

答：

1. sleep 方法：是 Thread 类的静态方法，当前线程将睡眠 n 毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进行可运行状态，等待 CPU 的到来。睡眠不释放锁（如果有的话）；
2. wait 方法：是 Object 的方法，必须与 synchronized 关键字一起使用，线程进入阻塞状态，当 notify 或者 notifyall 被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，释放互斥锁。

**6）synchronized 关键字：**

答：底层实现：

1. 进入时，执行 monitorenter，将计数器 +1，释放锁 monitorexit 时，计数器-1；
2. 当一个线程判断到计数器为 0 时，则当前锁空闲，可以占用；反之，当前线程进入等待状态。

含义：（monitor 机制）

Synchronized 是在加锁，加对象锁。对象锁是一种重量锁（monitor），synchronized  的锁机制会根据线程竞争情况在运行时会有偏向锁（单一线程）、轻量锁（多个线程访问 synchronized  区域）、对象锁（重量锁，多个线程存在竞争的情况）、自旋锁等。

该关键字是一个几种锁的封装。

**7）volatile 关键字**

答：该关键字可以保证可见性不保证原子性。

功能：

1. 主内存和工作内存，直接与主内存产生交互，进行读写操作，保证可见性；
2. 禁止 JVM 进行的指令重排序。

解析：关于指令重排序的问题，可以查阅 DCL 双检锁失效相关资料。

**8）ThreadLocal（线程局部变量）关键字：**

答：当使用 ThreadLocal 维护变量时，其为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程对应的副本。

ThreadLocal 内部实现机制：

1. 每个线程内部都会维护一个类似 HashMap 的对象，称为 ThreadLocalMap，里边会包含若干了 Entry（K-V 键值对），相应的线程被称为这些 Entry 的属主线程；
2. Entry 的 Key 是一个 ThreadLocal 实例，Value 是一个线程特有对象。Entry 的作用即是：为其属主线程建立起一个 ThreadLocal 实例与一个线程特有对象之间的对应关系；
3. Entry 对 Key 的引用是弱引用；Entry 对 Value 的引用是强引用。

**![img](http://mmbiz.qpic.cn/mmbiz_jpg/0vU1ia3htaaOibXu9vz5RhIObf10CiaFxEVApcdC7AxUkM5p3P3Vtg4iasxibgBeuZichqwKEVOibpRy5NVu40mQY1fsA/?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)**

**9）Atomic 关键字：**

答：可以使基本数据类型以原子的方式实现自增自减等操作。参考我的博客：concurrent.atomic 包下的类 AtomicInteger 的使用。

**10）线程池有了解吗？（必考）**

答：java.util.concurrent.ThreadPoolExecutor 类就是一个线程池。客户端调用 ThreadPoolExecutor.submit(Runnable task)  提交任务，线程池内部维护的工作者线程的数量就是该线程池的线程池大小，有 3 种形态：

> - 当前线程池大小 ：表示线程池中实际工作者线程的数量；
> - 最大线程池大小 （maxinumPoolSize）：表示线程池中允许存在的工作者线程的数量上限；
> - 核心线程大小 （corePoolSize ）：表示一个不大于最大线程池大小的工作者线程数量上限。

1. 如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队；
2. 如果运行的线程等于或者多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不是添加新线程；
3. 如果无法将请求加入队列，即队列已经满了，则创建新的线程，除非创建此线程超出 maxinumPoolSize， 在这种情况下，任务将被拒绝。

限于篇幅有限，更多高并发编程中的问题，请各位参阅我的博客：

- Java 多线程编程实战指南（核心篇）读书笔记（一）
- Java 多线程编程实战指南（核心篇）读书笔记（二）
- Java 多线程编程实战指南（核心篇）读书笔记（三）
- Java 多线程编程实战指南（核心篇）读书笔记（四）
- Java 多线程编程实战指南（核心篇）读书笔记（五）

> 小结：本小节内容涉及到 Java 中多线程编程，线程安全等知识，是面试中的重点和难点。

### （四）JVM 内存管理

既然是 Java 开发面试，那么对 JVM 的考察当然也是必须的，面试官一般会问你对 JVM 有了解吗？

我通常都会把我所了解的都说一遍，包括：JVM 内存划分、JVM 垃圾回收的含义，有哪些 GC 算法，年轻代和老年代各自的特点统统阐述一遍。

**1）JVM 内存划分：**

1. 方法区（线程共享）：常量、静态变量、JIT(即时编译器) 编译后的代码也都在方法区；
2. 堆内存（线程共享）：垃圾回收的主要场所；
3. 程序计数器： 当前线程执行的字节码的位置指示器；
4. 虚拟机栈（栈内存）：保存局部变量、基本数据类型变量以及堆内存中某个对象的引用变量；
5. 本地方法栈 ：为 JVM 提供使用 native 方法的服务。

**2）类似-Xms、-Xmn 这些参数的含义：**

答：

堆内存分配：

1. JVM 初始分配的内存由-Xms 指定，默认是物理内存的 1/64；
2. JVM 最大分配的内存由-Xmx 指定，默认是物理内存的 1/4；
3. 默认空余堆内存小于 40% 时，JVM 就会增大堆直到-Xmx 的最大限制；空余堆内存大于 70% 时，JVM 会减少堆直到 -Xms 的最小限制；
4. 因此服务器一般设置-Xms、-Xmx 相等以避免在每次 GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。

非堆内存分配：

1. JVM 使用-XX:PermSize 设置非堆内存初始值，默认是物理内存的 1/64；
2. 由 XX:MaxPermSize 设置最大非堆内存的大小，默认是物理内存的 1/4；
3. -Xmn2G：设置年轻代大小为 2G；
4. -XX:SurvivorRatio，设置年轻代中 Eden 区与 Survivor 区的比值。

**3）垃圾回收算法有哪些？**

答：

1. 引用计数 ：原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为 0 的对象。此算法最致命的是无法处理循环引用的问题；

2. 标记-清除 ：此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除；

   此算法需要暂停整个应用，同时，会产生内存碎片；

3. 复制算法 ：此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中；

   此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现 “碎片” 问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间；

4. 标记-整理 ：此算法结合了 “标记-清除” 和 “复制” 两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象 “压缩” 到堆的其中一块，按顺序排放。

   此算法避免了 “标记-清除” 的碎片问题，同时也避免了 “复制” 算法的空间问题。

**4）root 搜索算法中，哪些可以作为 root？**

答：

- 被启动类（bootstrap 加载器）加载的类和创建的对象；
- JavaStack 中的引用的对象 (栈内存中引用的对象)；
- 方法区中静态引用指向的对象；
- 方法区中常量引用指向的对象；
- Native 方法中 JNI 引用的对象。

**5）GC 什么时候开始？**

答：GC 经常发生的区域是堆区，堆区还可以细分为新生代、老年代，新生代还分为一个 Eden 区和两个 Survivor 区。

1. 对象优先在 Eden 中分配，当 Eden 中没有足够空间时，虚拟机将发生一次 Minor GC，因为 Java 大多数对象都是朝生夕灭，所以 Minor GC 非常频繁，而且速度也很快；

2. Full GC，发生在老年代的 GC，当老年代没有足够的空间时即发生 Full GC，发生 Full GC 一般都会有一次 Minor GC。

   大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个；XX:PretenureSizeThreadhold 参数，令大于这个参数值的对象直接在老年代中分配，避免在 Eden 区和两个 Survivor 区发生大量的内存拷贝；

3. 发生 Minor GC 时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次 Full  GC，如果小于，则查看 HandlePromotionFailure 设置是否允许担保失败，如果允许，那只会进行一次 Minor  GC，如果不允许，则改为进行一次 Full GC。

**6）内存泄漏和内存溢出**

答：

概念：

1. 内存溢出指的是内存不够用了；
2. 内存泄漏是指对象可达，但是没用了。即本该被 GC 回收的对象并没有被回收；
3. 内存泄露是导致内存溢出的原因之一；内存泄露积累起来将导致内存溢出。

内存泄漏的原因分析：

1. 长生命周期的对象引用短生命周期的对象；
2. 没有将无用对象置为 null。

> 小结：本小节涉及到 JVM 虚拟机，包括对内存的管理等知识，相对较深。除了以上问题，面试官会继续问你一些比较深的问题，可能也是为了看看你的极限在哪里吧。
>
> 比如：内存调优、内存管理，是否遇到过内存泄漏的实际案例、是否真正关心过内存等。由于本人实际项目经验不足，这些深层次问题并没有接触过，各位有需要可以上网查阅。

### （五）Java 8 相关知识点

关于 Java8 中新知识点，面试官会让你说说 Java8 你了解多少，下边主要阐述我所了解，并且在面试中回答的 Java8 新增知识点。

1）HashMap 的底层实现有变化：HashMap 是数组 + 链表 + 红黑树（JDK1.8 增加了红黑树部分）实现。

2）JVM 内存管理方面，由元空间代替了永久代。

区别：

1. 元空间并不在虚拟机中，而是使用本地内存；
2. 默认情况下，元空间的大小仅受本地内存限制；
3. 也可以通过-XX：MetaspaceSize 指定元空间大小。

3）Lambda 表达式（也称为闭包），允许我们将函数当成参数传递给某个方法，或者把代码本身当做数据处理。

4）函数式接口：指的是只有一个函数的接口，java.lang.Runnable 和 java.util.concurrent.Callable 就是函数式接口的例子；java8 提供了一个特殊的注解  @Functionallnterface 来标明该接口是一个函数式接口。

5）引入重复注解：Java 8 中使用 @Repeatable 注解定义重复注解。

6）接口中可以实现方法 default 方法。

7） 注解的使用场景拓宽： 注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上。

8） 新的包 java.time 包

1. 包含了所有关于日期、时间、时区、持续时间和时钟操作的类；
2. 这些类都是不可变的、线程安全的。

> 小结：Java8 的一些新特性，面试官一般情况下不要求你有多么精通，主要是看看你有没有一些了解。

### （六）网络协议相关

> 网络协议方面，考察最多的包括服务器和客户端在三次握手、四次挥手过程中的状态变化；还有网络拥塞控制，及其解决办法等。

**1）三次握手、四次挥手示意图：**

**![img](http://mmbiz.qpic.cn/mmbiz_jpg/0vU1ia3htaaOibXu9vz5RhIObf10CiaFxEVKlPMH6fdq80BhiaEqwEMNsSQ4icMXVMbd9fhA6gMId7CGAviacmJvibzlw/?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)**

总共有四种状态：主动建立连接、主动断开连接、被动建立连和被动断开连接

两两组合还是 4 种组合：

1. 主动建立连接、主动断开连接会经历的状态：
   SYNC_SENT——ESTABLISHED—-FIN_WAIT_1—-FIN_WAIT_2—-TIME_WAIT
2. 主动建立连接、被动断开连接会经历的状态：
   SYNC_SENT——ESTABLISHED—-CLOSE_WAIT—-LAST_ACK
3. 被动建立连接、主动断开连接会经历的状态：
   LISTEN—-SYN_RCVD—-ESTABLISHED—-FIN_WAIT_1—-FIN_WAIT_2—-TIME_WAIT
4. 被动建立连接、被动断开连接会经历的状态：
   LISTEN—-SYN_RCVD—-ESTABLISHED—-CLOSE_WAIT—-LAST_ACK

**2）滑动窗口机制**

由发送方和接收方在三次握手阶段，互相将自己的最大可接收的数据量告诉对方。也就是自己的数据接收缓冲池的大小。这样对方可以根据已发送的数据量来计算是否可以接着发送。

在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知。

**3）拥塞避免机制**

**拥塞：**对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。

**拥塞控制：**防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。

**拥塞控制方法：**

- 慢开始 + 拥塞避免；
- 快重传 + 快恢复。

![img](http://mmbiz.qpic.cn/mmbiz_png/0vU1ia3htaaOibXu9vz5RhIObf10CiaFxEV2iaXiamT52GkHNFtglg2bCU4kicFxp2RxrTicmrxibt2rdjia0ib4Y8hBx0hg/?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![img](http://mmbiz.qpic.cn/mmbiz_png/0vU1ia3htaaOibXu9vz5RhIObf10CiaFxEV2TpU4V9UDhmo5vNIGQGAcRWVGJof2icMMPm2XGZRL4A8t8aPliczibGjQ/?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**4）浏览器中输入：“www.xxx.com” 之后都发生了什么？请详细阐述。**

解析：经典的网络协议问题。

答：

1. 由域名→IP 地址
   寻找 IP 地址的过程依次经过了浏览器缓存、系统缓存、hosts 文件、路由器缓存、 递归搜索根域名服务器。

2. 建立 TCP/IP 连接（三次握手具体过程）

3. 由浏览器发送一个 HTTP 请求

4. 经过路由器的转发，通过服务器的防火墙，该 HTTP 请求到达了服务器

5. 服务器处理该 HTTP 请求，返回一个 HTML 文件

6. 浏览器解析该 HTML 文件，并且显示在浏览器端

7. 这里需要注意：

8. - HTTP 协议是一种基于 TCP/IP 的应用层协议，进行 HTTP 数据请求必须先建立 TCP/IP 连接
   - 可以这样理解：HTTP 是轿车，提供了封装或者显示数据的具体形式；Socket 是发动机，提供了网络通信的能力。
   - 两个计算机之间的交流无非是两个端口之间的数据通信 , 具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。

**5）常见 HTTP 状态码**

1. 1xx（临时响应）

2. 2xx（成功）

3. 3xx（重定向）：表示要完成请求需要进一步操作

4. 4xx（错误）：表示请求可能出错，妨碍了服务器的处理

5. 5xx（服务器错误）：表示服务器在尝试处理请求时发生内部错误

6. 常见状态码：

7. - 200（成功）
   - 304（未修改）：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容
   - 401（未授权）：请求要求身份验证
   - 403（禁止）：服务器拒绝请求
   - 404（未找到）：服务器找不到请求的网页

**6）TCP 和 UDP 的区别：**

答：

1. 回答发送数据前是否存在建立连接的过程；
2. ＴＣＰ过确认机制，丢包可以重发，保证数据的正确性；ＵＤＰ不保证正确性，只是单纯的负责发送数据包；
3. UDP 是面向报文的。发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付给 IP 层。既不拆分，也不合并，而是保留这些报文的边界，因 此，应用程序需要选择合适的报文大小；
4. UDP 的头部，只有 8 个字节，相对于 TCP 头部的 20 个字节信息包的额外开销很小。

限于篇幅，更多网络协议相关知识，请参阅我的博客：TCP/IP 协议面试常问知识点，倾心总结

> 小结：必须熟练掌握 TCP 和 UDP 的区别、三次握手和四次挥手的状态切换，必考。

### （七）数据库知识点

> 既然是后端开发，那么与数据库相关的知识点也是必不可少的。

**1）MySQL 和 MongoDB 的区别有哪些？如何选择？**

**2）MongoDB 的优缺点有哪些？**

（ps 本人对这一块不是很熟悉，就不附上参考答案了，请各位小伙伴自行学习哈~）

**3）听说过事务吗？（必考）**

答：作为单个逻辑工作单元执行的一系列操作，满足四大特性：

1. 原子性（Atomicity）：事务作为一个整体被执行 ，要么全部执行，要么全部不执行；
2. 一致性（Consistency）：保证数据库状态从一个一致状态转变为另一个一致状态；
3. 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行；
4. 持久性（Durability）：一个事务一旦提交，对数据库的修改应该永久保存。

**4）事务的并发问题有哪几种？**

答：丢失更新、脏读、不可重复读以及幻读。

**5）数据库中的锁有哪几种？**
答：独占锁、排他锁以及更新锁。

**6）事务的隔离级别有哪几种？**

答：读未提交、读已提交、可重复读和序列化。

扩展问题：MySQL 事务默认隔离级别是哪个？

答：可重复读。

解析：关于问题（4）（5）（6）的详细解答，请参阅我的博客：数据库并发机制和事务的隔离级别详解

（ps，关于数据库事务方面的深层次考察还有分布式事务即两段提交和三段提交等，限于本人水平，请各位自行学习）

**7）数据库的索引有什么作用？（必考） 底层数据结构是什么，为什么使用这种数据结构？**

答：

1. 索引  是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息；
2. 底层数据结构是 B+ 树；
3. 使用 B+ 树的原因：查找速度快、效率高，在查找的过程中，每次都能抛弃掉一部分节点，减少遍历个数。（ 此时，你应该在白纸上画出什么是 B+ 树 ）

扩展问题：聚簇索引和非聚簇索引的区别？

**8）MyISAM 和 InnoDB 的区别有哪些？**

答：

- MyISAM 不支持事务，InnoDB 是事务类型的存储引擎；
- MyISAM 只支持表级锁，BDB 支持页级锁和表级锁，默认为页级锁；而 InnoDB 支持行级锁和表级锁，默认为行级锁；
- MyISAM 引擎不支持外键，InnoDB 支持外键；
- MyISAM 引擎的表在大量高并发的读写下会经常出现表损坏的情况；
- 对于 count( ) 查询来说 MyISAM 更有优势；
- InnoDB 是为处理巨大数据量时的最大性能设计，它的 CPU 效率可能是任何其它基于磁盘的关系数据库引擎所不能匹敌的；
- MyISAM 支持全文索引（FULLTEXT），InnoDB 不支持；
- MyISAM 引擎的表的查询、更新、插入的效率要比 InnoDB 高。

> 最主要的区别是：MyISAM 表不支持事务、不支持行级锁、不支持外键。 InnoDB 表支持事务、支持行级锁、支持外键。**（可直接回答这个）**

**9）数据库中 Where、group by、having 关键字：**

答：  **关键字作用：**

1. where 子句用来筛选 from 子句中指定的操作所产生的的行；
2. group by 子句用来分组 where 子句的输出；
3. having 子句用来从分组的结果中筛选行；

**having 和 where 的区别：**

1. 语法类似，where 搜索条件在进行分组操作之前应用；having 搜索条件在进行分组操作之后应用；
2. having 可以包含聚合函数 sum、avg、max 等；
3. having 子句限制的是组，而不是行。

当同时含有 where 子句、group by 子句 、having 子句及聚集函数时，执行顺序如下：

1. 执行 where 子句查找符合条件的数据；
2. 使用 group by 子句对数据进行分组；对 group by 子句形成的组运行聚集函数计算每一组的值；最后用 having 子句去掉不符合条件的组。

**10）还有一些问题，如 MySQL 和 SQL Server 用法上的区别、limit 关键字的使用等问题。**

> 小结：数据库方面还是事务机制、隔离级别比较重要，当然了数据库索引是必考的问题。偶尔也会给你几个表，让你现场写 SQL 语句，主要考察 group by 和 having 等关键字。

### （八）MVC 框架相关知识点

> 我在项目中使用的框架有 Spring MVC 和 MyBatis，所以在简历上只写了这两种框架，面试官主要针对这两种框架进行提问。以下问题供小伙伴们参考。

JavaWeb 开发经典的 3 层框架：Web 层、Service 层（业务逻辑层）和 Dao 层（数据访问层）

- Web 层：包含 JSP 和 Servlet 等与 Web 相关的内容；
- 业务层：只关心业务逻辑；
- 数据层：封装了对数据库的访问细节。

Spring 知识点

**1）Spring 的 IOC 和 AOP 有了解吗？**

答：

- IOC：控制反转，（解耦合）将对象间的依赖关系交给 Spring 容器，使用配置文件来创建所依赖的对象，由主动创建对象改为了被动方式；
- AOP：面向切面编程，将功能代码从业务逻辑代码中分离出来。

**2）AOP 的实现方式有哪几种？如何选择？（必考）**

答：JDK 动态代理实现和 cglib 实现。

选择：

1. 如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理实现 AOP，也可以强制使用 cglib 实现 AOP；
2. 如果目标对象没有实现接口，必须采用 cglib 库，Spring 会自动在 JDK 动态代理和 cglib 之间转换。

**扩展：JDK 动态代理如何实现？（加分点）**

答：JDK 动态代理，只能对实现了接口的类生成代理，而不是针对类，该目标类型实现的接口都将被代理。原理是通过在运行期间创建一个接口的实现类来完成对目标对象的代理。

1. 定义一个实现接口 InvocationHandler 的类；
2. 通过构造函数，注入被代理类；
3. 实现 invoke（ Object proxy, Method method, Object[] args）方法；
4. 在主函数中获得被代理类的类加载器；
5. 使用 Proxy.newProxyInstance( ) 产生一个代理对象；
6. 通过代理对象调用各种方法。

解析：关于 IOC 和 AOP 的详细阐述，请各位参阅我的博客：Spring 核心 AOP（面向切面编程）总结，Spring 框架学习—控制反转（IOC）

**3）Spring MVC 的核心控制器是什么？消息处理流程有哪些？**

答：核心控制器为 DispatcherServlet。消息流程如下：



![img](http://mmbiz.qpic.cn/mmbiz_png/0vU1ia3htaaOibXu9vz5RhIObf10CiaFxEVFANG3sngVibNPF8dyrspKLgVWuDC7ibbzzj1j8Paibde1X2mjkuzPicgnQ/?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**4）其他问题包括：重定向和转发的区别、动态代理和静态代理的区别等。**

Mybatis 知识点

关于 MyBatis 主要考察占位符#和 $ 的区别，区别如下：

1. # 符号将传入的数据都当做一个字符串，会对自动传入的数据加一个双引号；

2. # $ 符号将传入的数据直接显示生成 SQL 中；

3. 符号存在预编译的过程，，对问号赋值，防止 SQL 注入；

4. $ 符号是直译的方式，一般用在 order by ${列名}语句中；

5. 能用#号就不要用 $ 符号。

> 小结：限于作者水平，MVC 框架方面了解不是太多，实战能力欠缺。面试官偶尔问框架底层实现原理等都知之甚少，有能力的小伙伴可以多加学习。

### （九）大数据相关知识点

> 大数据相关是因为我的简历上写了 KafKa 相关项目，所以面试官会进行提问 KafKa 相关知识点，我也进行了一些简单概念总结，深层次的实现原理因为并没有特别多的实战经验，所以并不了解。

以下概念总结供小伙伴参考。

**1）KafKa 基本特性：**

答：快速持久化、支持批量读写消息、支持消息分区，提高了并发能力、支持在线增加分区、支持为每个分区创建多个副本。

扩展：为什么可以实现快速持久化？

答：KafKa 将消息保存在磁盘中，并且读写磁盘的方式是顺序读写，避免了随机读写磁盘（寻道时间过长）导致的性能瓶颈；磁盘的顺序读写速度超过内存随机读写。

**2）核心概念：**

答：

- 生产者（Producer）： 生产消息，并且按照一定的规则推送到 Topic 的分区中。

- 消费者（Consumer）： 从 Topic 中拉去消息，并且进行消费。

- 主题（Topic）： 用于存储消息的逻辑概念，是一个消息集合。

- 分区（partition）：

- 1. 每个 Topic 可以划分为多个分区，每个消息在分区中都会有一个唯一编号 offset
  2. kafka 通过 offset 保证消息在分区中的顺序
  3. 同一 Topic 的不同分区可以分配在不同的 Broker 上
  4. partition 以文件的形式存储在文件系统中。

副本（replica）：

1. KafKa 对消息进行了冗余备份，每个分区有多个副本，每个副本中包含的消息是 “一样” 的。
2. 每个副本中都会选举出一个 Leader 副本，其余为 Follower 副本，Follower 副本仅仅将数据从 Leader 副本拉去到本地，然后同步到自己的 Log 中。

消费者组（Consumer Group）： 每个 consumer 都属于一个 consumer group，每条消息只能被 consumer group 中的一个 Consumer 消费，但可以被多个 consumer group 消费。

Broker：

1. 一个单独的 server 就是一个 Broker；
2. 主要工作：接收生产者发过来的消息，分配 offset，并且保存到磁盘中；

Cluster&Controller：

1. 多个 Broker 可以组成一个 Cluster，每个集群选举一个 Broker 来作为 Controller，充当指挥中心
2. Controller 负责管理分区的状态，管理每个分区的副本状态，监听 ZooKeeper 中数据的变化等工作

保留策略和日志压缩：

1. 不管消费者是否已经消费了消息，KafKa 都会一直保存这些消息（持久化到磁盘）；
2. 通过保留策略，定时删除陈旧的消息；
3. 日志压缩，只保留最新的 Key-Value 对。

**关于副本机制：（加分点）**

ISR 集合 ：表示当前 “可用” 且消息量与 Leader 相差不多的副本集合。满足条件如下：

1. 副本所在节点必须维持着与 ZooKeeper 的连接；
2. 副本最后一条信息的 offset 与 Leader 副本的最后一条消息的 offset 之间的差值不能超过指定的阈值。

HW&LEO：

1. HW 标记了一个特殊的 offset，当消费者处理消息的时候，只能拉取到 HW 之前的消息；
2. HW 也是由 Leader 副本管理的；
3. LEO（Log End Offset）是所有副本都会有的一个 offset 标记。

ISR、HW 和 LEO 的工作配合：

1. producer 向此分区中推送消息；
2. Leader 副本将消息追加到 Log 中，并且递增其 LEO；
3. Follower 副本从 Leader 副本中拉取消息进行同步；
4. Follower 副本将消息更新到本地 Log 中，并且递增其 LEO；
5. 当 ISR 集合中的所有副本都完成了对 offset 的消息同步，Leader 副本会递增其 HW

KafKa 的容灾机制： 通过分区的副本 Leader 副本和 Follower 副本来提高容灾能力。

> 小结：请小伙伴根据自己的简历自行准备学习大数据相关知识点。

### （十）Linux 常见命令

> 作者对这一方面不是很精通，知识点来源于网络总结以及面试官的提问，仅供小伙伴参考。

**1）grep、sed 以及 awk 命令**

解析：awk 命令如果可以掌握，是面试中的一个  加分点。

**2）文件和目录：**

> pwd 显示当前目录

ls 显示当前目录下的文件和目录：

1. ls -F 可以区分文件和目录；
2. ls -a 可以把隐藏文件和普通文件一起显示出来；
3. ls -R 可以递归显示子目录中的文件和目录；
4. ls -l 显示长列表；
5. ls -l test 过滤器，查看某个特定文件信息。可以只查看 test 文件的信息。

**3）处理文件方面的命令有：touch、cp、 In、mv、rm、**      

**4）处理目录方面的命令：mkdir**

**5）查看文件内容：file、cat、more、less、tail、head**

**6）监测程序命令：ps、top**

eg. 找出进程名中包括 java 的所有进程：ps -ef | grep java

top 命令 实时监测进程

top 命令输出的第一部分：显示系统的概括。

1. 第一行显示了当前时间、系统的运行时间、登录的用户数和系统的平均负载（平均负载有 3 个值：最近 1min 5min 15min）；
2. 第二行显示了进程的概要信息，有多少进程处于运行、休眠、停止或者僵化状态；
3. 第三行是 CPU 的概要信息；
4. 第四行是系统内存的状态。

**7）ps 和 top 命令的区别：**

1. ps 看到的是命令执行瞬间的进程信息 , 而 top 可以持续的监视；
2. ps 只是查看进程 , 而 top 还可以监视系统性能 , 如平均负载 ,cpu 和内存的消耗；
3. 另外 top 还可以操作进程 , 如改变优先级 (命令 r) 和关闭进程 (命令 k)；
4. ps 主要是查看进程的，关注点在于查看需要查看的进程；
5. top 主要看 cpu, 内存使用情况，及占用资源最多的进程由高到低排序，关注点在于资源占用情况。

**8） 压缩数据**

1. tar -xvf 文件名；
2. tar -zxvf 文件名；
3. tar -cvzf 文件名。

**9）结束进程：kill PID 或者 kill all**

至此，从十个不同的方面阐述了 Java 开发面试岗位中所涉及到的重要知识点。加上我上次发布的 关于算法面试的 chat，我大概将最近一年的时间内的面试笔试经验给大家做了总结分享。

